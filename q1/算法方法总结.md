# 第一题算法方法总结

## 🎯 **实际使用的算法方法**

### **1. 启发式搜索算法**
```python
# 不是穷举搜索，而是基于优先级的启发式搜索
test_allocations = [
    (20, 20, 10),  # 优先满足eMBB和URLLC，mMTC分配剩余
    (20, 25, 5),   # 优先满足eMBB，然后URLLC，mMTC最少
    (15, 25, 10),  # 优先满足eMBB，URLLC部分满足，mMTC分配剩余
    (25, 15, 10),  # 优先满足URLLC，eMBB部分满足，mMTC分配剩余
    (30, 15, 5),   # 优先满足URLLC，eMBB部分满足，mMTC最少
]
```

### **2. 优先级分配策略**

#### **切片间优先级**
```
eMBB > URLLC > mMTC（按QoS贡献排序）
- eMBB: 平均QoS贡献3.6000（最高）
- URLLC: 平均QoS贡献1.7919
- mMTC: 平均QoS贡献0.4200
```

#### **切片内部优先级**
```
按用户编号排序：
- URLLC: U1 > U2
- eMBB: e1 > e2 > e3 > e4  
- mMTC: m1 > m2 > ... > m10
```

### **3. 约束检查方法**

#### **资源块倍数约束**
```python
urllc_valid = urllc_rbs % 10 == 0  # URLLC必须是10的倍数
embb_valid = embb_rbs % 5 == 0     # eMBB必须是5的倍数
mmtc_valid = mmtc_rbs % 2 == 0     # mMTC必须是2的倍数
```

#### **用户服务约束**
```python
urllc_served = urllc_rbs // 10  # URLLC可服务用户数
embb_served = embb_rbs // 5     # eMBB可服务用户数
```

### **4. mMTC优先级分配算法**

```python
def calculate_mmtc_priority_allocation_fixed(mmtc_rbs, user_data):
    # 1. 计算完整约束用户数
    full_constraint_users = mmtc_rbs // 2  # 可以分配2RB的用户数
    remaining_rbs = mmtc_rbs % 2          # 剩余资源块
    
    # 2. 按用户编号排序（符合题目要求）
    user_list.sort(key=lambda x: x['user_number'])
    
    # 3. 优先级分配
    for i, user_info in enumerate(user_list):
        if i < full_constraint_users:
            # 满足完整约束的用户（分配2RB）
            allocation.append({'rbs': 2, 'constraint_satisfied': True})
        elif i < full_constraint_users + remaining_rbs:
            # 分配1RB的用户
            allocation.append({'rbs': 1, 'constraint_satisfied': False})
        else:
            # 没有分配到资源的用户
            allocation.append({'rbs': 0, 'constraint_satisfied': False})
```

### **5. QoS计算方法**

#### **SINR计算**
```python
def calculate_sinr(power_dbm, large_scale_db, small_scale, num_rbs):
    # 接收功率计算
    received_power = 10**((power_dbm - large_scale_db) / 10) * small_scale
    
    # 噪声功率计算
    noise_power_dbm = thermal_noise + 10 * math.log10(num_rbs * bandwidth_per_rb) + NF
    noise_power_mw = 10**((noise_power_dbm - 30) / 10)
    
    # SINR计算
    sinr = received_power / noise_power_mw
    return sinr
```

#### **传输速率计算**
```python
def calculate_rate(sinr, num_rbs):
    rate = num_rbs * bandwidth_per_rb * math.log2(1 + sinr)
    return rate / 1e6  # 转换为Mbps
```

#### **QoS计算**
```python
# URLLC QoS
def calculate_urllc_qos(rate, delay):
    if delay <= 5:  # 5ms
        return 0.95 ** delay  # α^L
    else:
        return -5  # 惩罚

# eMBB QoS  
def calculate_embb_qos(rate, delay):
    if delay <= 100:  # 100ms
        if rate >= 50:  # 50Mbps
            return 1.0
        else:
            return rate / 50  # r/r_SLA
    else:
        return -3  # 惩罚

# mMTC QoS
def calculate_mmtc_qos(connection_ratio, delay):
    if delay <= 500:  # 500ms
        return connection_ratio  # 接入比例
    else:
        return -1  # 惩罚
```

## 🔍 **算法特点**

### **1. 搜索策略**
- **启发式搜索**：不是穷举所有组合，而是基于优先级设计候选方案
- **候选方案数量**：5个预定义的分配方案
- **时间复杂度**：O(1)，固定5个方案

### **2. 优先级策略**
- **切片间**：按QoS贡献排序
- **切片内**：按用户编号排序
- **mMTC特殊**：按用户编号优先级分配剩余资源

### **3. 约束处理**
- **硬约束**：URLLC和eMBB必须满足倍数约束
- **软约束**：mMTC允许部分满足，采用优先级分配

### **4. 评估方法**
- **QoS计算**：严格按照SLA定义
- **约束检查**：检查倍数约束和用户服务约束
- **最优选择**：选择总QoS最高的方案

## 📊 **算法优势**

1. **高效性**：只测试5个候选方案，计算速度快
2. **合理性**：基于QoS贡献的优先级策略
3. **公平性**：按用户编号排序确保公平
4. **实用性**：适应资源不足的实际情况

## 🎯 **最终结果**

**最优方案**: URLLC=20, eMBB=20, mMTC=10
**总QoS**: 6.4910
**算法类型**: 启发式搜索 + 优先级分配 